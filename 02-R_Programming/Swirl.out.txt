
| Excellent work!

  |======================================================================================================                                                                                               |  52%
| Now let's try out the non-vectorized version of the OR operator. Type the expression TRUE || c(TRUE, FALSE, FALSE).

> TRUE || c(TRUE, FALSE, FALSE)
[1] TRUE

| That's a job well done!

  |==========================================================================================================                                                                                           |  54%
| Logical operators can be chained together just like arithmetic operators. The expressions: `6 != 10 && FALSE && 1 >= 2` or `TRUE || 5 < 9.3 || FALSE` are perfectly normal to see.

...

  |==============================================================================================================                                                                                       |  56%
| As you may recall, arithmetic has an order of operations and so do logical expressions. All AND operators are evaluated before OR operators. Let's look at an example of an ambiguous case. Type: 5 > 8 || 6
| != 8 && 4 > 3.9

> 5 > 8 || 6 != 8 && 4 > 3.9
[1] TRUE

| You're the best!

  |==================================================================================================================                                                                                   |  58%
| Let's walk through the order of operations in the above case. First the left and right operands of the AND operator are evaluated. 6 is not equal 8, 4 is greater than 3.9, therefore both operands are TRUE
| so the resulting expression `TRUE && TRUE` evaluates to TRUE. Then the left operand of the OR operator is evaluated: 5 is not greater than 8 so the entire expression is reduced to FALSE || TRUE. Since the
| right operand of this expression is TRUE the entire expression evaluates to TRUE.

...

  |=====================================================================================================================                                                                                |  60%
| Which one of the following expressions evaluates to TRUE?

1: 99.99 > 100 || 45 < 7.3 || 4 != 4.0
2: TRUE && 62 < 62 && 44 >= 44
3: FALSE || TRUE && FALSE
4: TRUE && FALSE || 9 >= 4 && 3 < 6

Selection: 4

| You are doing so well!

  |=========================================================================================================================                                                                            |  62%
| Which one of the following expressions evaluates to FALSE?

1: FALSE || TRUE && 6 != 4 || 9 > 4
2: 6 >= -9 && !(6 > 7) && !(!TRUE)
3: !(8 > 4) ||  5 == 5.0 && 7.8 >= 7.79
4: FALSE && 6 >= 6 || 7 >= 8 || 50 <= 49.5

Selection: 4

| You got it right!

  |=============================================================================================================================                                                                        |  63%
| Now that you're familiar with R's logical operators you can take advantage of a few functions that R provides for dealing with logical expressions.

...

  |=================================================================================================================================                                                                    |  65%
| The function isTRUE() takes one argument. If that argument evaluates to TRUE, the function will return TRUE. Otherwise, the function will return FALSE. Try using this function by typing: isTRUE(6 > 4)

> isTRUE(6>4)
[1] TRUE

| That's a job well done!

  |=====================================================================================================================================                                                                |  67%
| Which of the following evaluates to TRUE?

1: isTRUE(3)
2: !isTRUE(8 != 5)
3: isTRUE(!TRUE)
4: !isTRUE(4 < 3)
5: isTRUE(NA)

Selection: 1

| That's not exactly what I'm looking for. Try again.

| isTRUE() will only return TRUE if the statement passed to it as an argument is TRUE.

1: isTRUE(NA)
2: isTRUE(!TRUE)
3: !isTRUE(4 < 3)
4: isTRUE(3)
5: !isTRUE(8 != 5)

Selection: 3

| That's the answer I was looking for.

  |========================================================================================================================================                                                             |  69%
| The function identical() will return TRUE if the two R objects passed to it as arguments are identical. Try out the identical() function by typing: identical('twins', 'twins')

> identical('twins', 'twins')
[1] TRUE

| You are really on a roll!

  |============================================================================================================================================                                                         |  71%
| Which of the following evaluates to TRUE?

1: identical(4, 3.1)
2: identical('hello', 'Hello')
3: !identical(7, 7)
4: identical(5 > 4, 3 < 3.1)

Selection: 4

| Keep working like that and you'll get there!

  |================================================================================================================================================                                                     |  73%
| You should also be aware of the xor() function, which takes two arguments. The xor() function stands for exclusive OR. If one argument evaluates to TRUE and one argument evaluates to FALSE, then this
| function will return TRUE, otherwise it will return FALSE. Try out the xor() function by typing: xor(5 == 6, !FALSE)

> xor(5==6,!FALSE)
[1] TRUE

| You got it!

  |====================================================================================================================================================                                                 |  75%
| 5 == 6 evaluates to FALSE, !FALSE evaluates to TRUE, so xor(FALSE, TRUE) evaluates to TRUE. On the other hand if the first argument was changed to 5 == 5 and the second argument was unchanged then both
| arguments would have been TRUE, so xor(TRUE, TRUE) would have evaluated to FALSE.

...

  |========================================================================================================================================================                                             |  77%
| Which of the following evaluates to FALSE?

1: xor(!!TRUE, !!FALSE)
2: xor(identical(xor, 'xor'), 7 == 7.0)
3: xor(!isTRUE(TRUE), 6 > -1)
4: xor(4 >= 9, 8 != 8.0)

Selection: 3

| That's not exactly what I'm looking for. Try again.

| For xor() to evaluate to TRUE, one argument must be TRUE and one must be FALSE.

1: xor(!!TRUE, !!FALSE)
2: xor(4 >= 9, 8 != 8.0)
3: xor(!isTRUE(TRUE), 6 > -1)
4: xor(identical(xor, 'xor'), 7 == 7.0)

Selection: 2

| Keep working like that and you'll get there!

  |===========================================================================================================================================================                                          |  79%
| For the next few questions, we're going to need to create a vector of integers called ints. Create this vector by typing: ints <- sample(10)

> ints<-sample(10)

| You're the best!

  |===============================================================================================================================================================                                      |  81%
| Now simply display the contents of ints.

> ints
 [1]  3  5  2  1  7  8 10  4  6  9

| Great job!

  |===================================================================================================================================================================                                  |  83%
| The vector `ints` is a random sampling of integers from 1 to 10 without replacement. Let's say we wanted to ask some logical questions about contents of ints. If we type ints > 5, we will get a logical
| vector corresponding to whether each element of ints is greater than 5. Try typing: ints > 5

> ints>5
 [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE

| All that hard work is paying off!

  |=======================================================================================================================================================================                              |  85%
| We can use the resulting logical vector to ask other questions about ints. The which() function takes a logical vector as an argument and returns the indices of the vector that are TRUE. For example
| which(c(TRUE, FALSE, TRUE)) would return the vector c(1, 3).

...

  |==========================================================================================================================================================================                           |  87%
| Use the which() function to find the indices of ints that are greater than 7.

> which(ints>7)
[1]  6  7 10

| You are amazing!

  |==============================================================================================================================================================================                       |  88%
| Which of the following commands would produce the indices of the elements in ints that are less than or equal to 2?

1: which(ints < 2)
2: ints < 2
3: which(ints <= 2)
4: ints <= 2

Selection: 3

| Perseverance, that's the answer.

  |==================================================================================================================================================================================                   |  90%
| Like the which() function, the functions any() and all() take logical vectors as their argument. The any() function will return TRUE if one or more of the elements in the logical vector is TRUE. The all()
| function will return TRUE if every element in the logical vector is TRUE.

...

  |======================================================================================================================================================================================               |  92%
| Use the any() function to see if any of the elements of ints are less than zero.

> any(ints<0)
[1] FALSE

| You are really on a roll!

  |==========================================================================================================================================================================================           |  94%
| Use the all() function to see if all of the elements of ints are greater than zero.

> all(ints>0)
[1] TRUE

| You nailed it! Good job!

  |=============================================================================================================================================================================================        |  96%
| Which of the following evaluates to TRUE?

1: any(ints == 10)
2: any(ints == 2.5)
3: all(ints == 10)
4: all(c(TRUE, FALSE, TRUE))

Selection: 1

| Perseverance, that's the answer.

  |=================================================================================================================================================================================================    |  98%
| That's all for this introduction to logic in R. If you really want to see what you can do with logic, check out the control flow lesson!

...

  |=====================================================================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 2
What is your email address? rjimenez@comunicaciones.es
What is your assignment token? puJqWOW10as3LAbN
Grade submission succeeded!

| That's the answer I was looking for.

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics             

Selection: 9

  |                                                                                                                                                                                                     |   0%

| Functions are one of the fundamental building blocks of the R language. They are small pieces of reusable code that can be treated like any other R object.

...

  |====                                                                                                                                                                                                 |   2%
| If you've worked through any other part of this course, you've probably used some functions already. Functions are usually characterized by the name of the function followed by parentheses.

...

  |========                                                                                                                                                                                             |   4%
| Let's try using a few basic functions just for fun. The Sys.Date() function returns a string representing today's date. Type Sys.Date() below and see what happens.

> Sys.Date()
[1] "2020-11-01"

| All that practice is paying off!

  |============                                                                                                                                                                                         |   6%
| Most functions in R return a value. Functions like Sys.Date() return a value based on your computer's environment, while other functions manipulate input data in order to compute a return value.

...

  |================                                                                                                                                                                                     |   8%
| The mean() function takes a vector of numbers as input, and returns the average of all of the numbers in the input vector. Inputs to functions are often called arguments. Providing arguments to a function
| is also sometimes called passing arguments to that function. Arguments you want to pass to a function go inside the function's parentheses. Try passing the argument c(2, 4, 5) to the mean() function.

> mean(c(2,4,5))
[1] 3.666667

| Nice work!

  |====================                                                                                                                                                                                 |  10%
| Functions usually take arguments which are variables that the function operates on. For example, the mean() function takes a vector as an argument, like in the case of mean(c(2,6,8)). The mean() function
| then adds up all of the numbers in the vector and divides that sum by the length of the vector.

...

  |========================                                                                                                                                                                             |  12%
| In the following question you will be asked to modify a script that will appear as soon as you move on from this question. When you have finished modifying the script, save your changes to the script and
| type submit() and the script will be evaluated. There will be some comments in the script that opens up, so be sure to read them!

...

  |============================                                                                                                                                                                         |  14%
| The last R expression to be evaluated in a function will become the return value of that function. We want this function to take one argument, x, and return x without modifying it. Delete the pound sign
| so that x is returned without any modification. Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| Your dedication is inspiring!

  |================================                                                                                                                                                                     |  16%
| Now that you've created your first function let's test it! Type: boring_function('My first function!'). If your function works, it should just return the string: 'My first function!'

> boring_function('My first function!')
[1] "My first function!"

| Your dedication is inspiring!

  |====================================                                                                                                                                                                 |  18%
| Congratulations on writing your first function. By writing functions, you can gain serious insight into how R works. As John Chambers, the creator of R once said:
| 
| To understand computations in R, two slogans are helpful: 1. Everything that exists is an object. 2. Everything that happens is a function call.

...

  |========================================                                                                                                                                                             |  20%
| If you want to see the source code for any function, just type the function name without any arguments or parentheses. Let's try this out with the function you just created. Type: boring_function to view
| its source code.

> boring_function
function(x) {
  x
}
<bytecode: 0x5643670310c0>

| Excellent work!

  |============================================                                                                                                                                                         |  22%
| Time to make a more useful function! We're going to replicate the functionality of the mean() function by creating a function called: my_mean(). Remember that to calculate the average of all of the
| numbers in a vector you find the sum of all the numbers in the vector, and then divide that sum by the number of numbers in the vector.

...

  |================================================                                                                                                                                                     |  24%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| All that hard work is paying off!

  |====================================================                                                                                                                                                 |  27%
| Now test out your my_mean() function by finding the mean of the vector c(4, 5, 10).

> my_mean(c(4,5,10))
[1] 6.333333

| You nailed it! Good job!

  |========================================================                                                                                                                                             |  29%
| Next, let's try writing a function with default arguments. You can set default values for a function's arguments, and this can be useful if you think someone who uses your function will set a certain
| argument to the same value most of the time.

...

  |============================================================                                                                                                                                         |  31%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| All that hard work is paying off!

  |================================================================                                                                                                                                     |  33%
| Let's do some testing of the remainder function. Run remainder(5) and see what happens.

> remainder(5)
[1] 1

| All that practice is paying off!

  |====================================================================                                                                                                                                 |  35%
| Let's take a moment to examine what just happened. You provided one argument to the function, and R matched that argument to 'num' since 'num' is the first argument. The default value for 'divisor' is 2,
| so the function used the default value you provided.

...

  |========================================================================                                                                                                                             |  37%
| Now let's test the remainder function by providing two arguments. Type: remainder(11, 5) and let's see what happens.

> remainder(11,5)
[1] 1

| That's the answer I was looking for.

  |============================================================================                                                                                                                         |  39%
| Once again, the arguments have been matched appropriately.

...

  |================================================================================                                                                                                                     |  41%
| You can also explicitly specify arguments in a function. When you explicitly designate argument values by name, the ordering of the arguments becomes unimportant. You can try this out by typing:
| remainder(divisor = 11, num = 5).

> remainder(divisor = 11, num = 5)
[1] 5

| You are doing so well!

  |====================================================================================                                                                                                                 |  43%
| As you can see, there is a significant difference between remainder(11, 5) and remainder(divisor = 11, num = 5)!

...

  |========================================================================================                                                                                                             |  45%
| R can also partially match arguments. Try typing remainder(4, div = 2) to see this feature in action.

> remainder(4,div=2)
[1] 0

| You got it!

  |============================================================================================                                                                                                         |  47%
| A word of warning: in general you want to make your code as easy to understand as possible. Switching around the orders of arguments by specifying their names or only using partial argument names can be
| confusing, so use these features with caution!

...

  |================================================================================================                                                                                                     |  49%
| With all of this talk about arguments, you may be wondering if there is a way you can see a function's arguments (besides looking at the documentation). Thankfully, you can use the args() function! Type:
| args(remainder) to examine the arguments for the remainder function.

> args(remainder)
function (num, divisor = 2) 
NULL

| You are amazing!

  |=====================================================================================================                                                                                                |  51%
| You may not realize it but I just tricked you into doing something pretty interesting! args() is a function, remainder() is a function, yet remainder was an argument for args(). Yes it's true: you can
| pass functions as arguments! This is a very powerful concept. Let's write a script to see how it works.

...

  |=========================================================================================================                                                                                            |  53%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| That's a job well done!

  |=============================================================================================================                                                                                        |  55%
| Let's take your new evaluate() function for a spin! Use evaluate to find the standard deviation of the vector c(1.4, 3.6, 7.9, 8.8).

> evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
[1] 3.514138

| You are really on a roll!

  |=================================================================================================================                                                                                    |  57%
| The idea of passing functions as arguments to other functions is an important and fundamental concept in programming.

...

  |=====================================================================================================================                                                                                |  59%
| You may be surprised to learn that you can pass a function as an argument without first defining the passed function. Functions that are not named are appropriately known as anonymous functions.

...

  |=========================================================================================================================                                                                            |  61%
| Let's use the evaluate function to explore how anonymous functions work. For the first argument of the evaluate function we're going to write a tiny function that fits on one line. In the second argument
| we'll pass some data to the tiny anonymous function in the first argument.

...

  |=============================================================================================================================                                                                        |  63%
| Type the following command and then we'll discuss how it works: evaluate(function(x){x+1}, 6)

> evaluate(function(x){x+1}, 6)
[1] 7

| All that hard work is paying off!

  |=================================================================================================================================                                                                    |  65%
| The first argument is a tiny anonymous function that takes one argument `x` and returns `x+1`. We passed the number 6 into this function so the entire expression evaluates to 7.

...

  |=====================================================================================================================================                                                                |  67%
| Try using evaluate() along with an anonymous function to return the first element of the vector c(8, 4, 0). Your anonymous function should only take one argument which should be a variable `x`.

> evaluate(function(x){x[1]},c(8, 4, 0))
[1] 8

| You are really on a roll!

  |=========================================================================================================================================                                                            |  69%
| Now try using evaluate() along with an anonymous function to return the last element of the vector c(8, 4, 0). Your anonymous function should only take one argument which should be a variable `x`.

> evaluate(function(x){x[length(x)]},c(8, 4, 0))
[1] 0

| You are amazing!

  |=============================================================================================================================================                                                        |  71%
| For the rest of the course we're going to use the paste() function frequently. Type ?paste so we can take a look at the documentation for the paste function.

> ?paste

| All that practice is paying off!

  |=================================================================================================================================================                                                    |  73%
| As you can see the first argument of paste() is `...` which is referred to as an ellipsis or simply dot-dot-dot. The ellipsis allows an indefinite number of arguments to be passed into a function. In the
| case of paste() any number of strings can be passed as arguments and paste() will return all of the strings combined into one string.

...

  |=====================================================================================================================================================                                                |  76%
| Just to see how paste() works, type paste("Programming", "is", "fun!")

> paste("Programming", "is", "fun!")
[1] "Programming is fun!"

| Nice work!

  |=========================================================================================================================================================                                            |  78%
| Time to write our own modified version of paste().

...

  |=============================================================================================================================================================                                        |  80%
| Make sure to save your script before you type submit().

> submit()

| Sourcing your script...


| You are really on a roll!

  |=================================================================================================================================================================                                    |  82%
| Now let's test out your telegram function. Use your new telegram function passing in whatever arguments you wish!

> telegram("Hola")
[1] "START Hola STOP"

| Keep up the great work!

  |=====================================================================================================================================================================                                |  84%
| Make sure to save your script before you type submit().

> 
> submit()

| Sourcing your script...


| Your dedication is inspiring!

  |=========================================================================================================================================================================                            |  86%
| Time to use your mad_libs function. Make sure to name the place, adjective, and noun arguments in order for your function to work.

> mad_libs(place="Jerez", adjective="brillante", noun="estudiantes")
[1] "News from Jerez today where brillante students took to the streets in protest of the new estudiantes being installed on campus."

| You nailed it! Good job!

  |=============================================================================================================================================================================                        |  88%
| We're coming to the end of this lesson, but there's still one more idea you should be made aware of.

...

  |=================================================================================================================================================================================                    |  90%
| You're familiar with adding, subtracting, multiplying, and dividing numbers in R. To do this you use the +, -, *, and / symbols. These symbols are called binary operators because they take two inputs, an
| input from the left and an input from the right.

...

  |=====================================================================================================================================================================================                |  92%
| In R you can define your own binary operators. In the next script I'll show you how.

...

  |=========================================================================================================================================================================================            |  94%
| Make sure to save your script before you type submit().

> source('/tmp/Rtmp6xhxNS/bin_op.R')
> submit()

| Sourcing your script...


| Nice work!

  |=============================================================================================================================================================================================        |  96%
| You made your own binary operator! Let's test it out. Paste together the strings: 'I', 'love', 'R!' using your new binary operator.

> 'I' %p% 'love' %p% 'R!'
[1] "I love R!"

| You're the best!

  |=================================================================================================================================================================================================    |  98%
| We've come to the end of our lesson! Go out there and write some great functions!

...

  |=====================================================================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: Yes
2: No

Selection: 1
What is your email address? rjimenez@comunicaciones.es
What is your assignment token? wXFdKCjV86YQv3H0
Grade submission succeeded!

| Great job!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 1

| Please choose a lesson, or type 0 to return to course menu.

 1: Basic Building Blocks      2: Workspace and Files        3: Sequences of Numbers       4: Vectors                    5: Missing Values             6: Subsetting Vectors      
 7: Matrices and Data Frames   8: Logic                      9: Functions                 10: lapply and sapply         11: vapply and tapply         12: Looking at Data         
13: Simulation                14: Dates and Times           15: Base Graphics             

Selection: 14

  |                                                                                                                                                                                                     |   0%

| R has a special way of representing dates and times, which can be helpful if you're working with data that show how something changes over time (i.e. time-series data) or if your data contain some other
| temporal information, like dates of birth.

...

  |=====                                                                                                                                                                                                |   3%
| Dates are represented by the 'Date' class and times are represented by the 'POSIXct' and 'POSIXlt' classes. Internally, dates are stored as the number of days since 1970-01-01 and times are stored as
| either the number of seconds since 1970-01-01 (for 'POSIXct') or a list of seconds, minutes, hours, etc. (for 'POSIXlt').

...

  |===========                                                                                                                                                                                          |   6%
| Let's start by using d1 <- Sys.Date() to get the current date and store it in the variable d1. (That's the letter 'd' and the number 1.)

> d1 <- Sys.Date()

| Excellent work!

  |================                                                                                                                                                                                     |   8%
| Use the class() function to confirm d1 is a Date object.

> class(d1)
[1] "Date"

| You got it!

  |======================                                                                                                                                                                               |  11%
| We can use the unclass() function to see what d1 looks like internally. Try it out.

> unclass(d1)
[1] 18567

| All that practice is paying off!

  |===========================                                                                                                                                                                          |  14%
| That's the exact number of days since 1970-01-01!

...

  |=================================                                                                                                                                                                    |  17%
| However, if you print d1 to the console, you'll get today's date -- YEAR-MONTH-DAY. Give it a try.

> d1
[1] "2020-11-01"

| You are really on a roll!

  |======================================                                                                                                                                                               |  19%
| What if we need to reference a date prior to 1970-01-01? Create a variable d2 containing as.Date("1969-01-01").

> d2<.as.Date("1969-01-01")
Error: object 'd2' not found
> d2<-as.Date("1969-01-01")

| Excellent work!

  |============================================                                                                                                                                                         |  22%
| Now use unclass() again to see what d2 looks like internally.

> unclass(d2)
[1] -365

| That's correct!

  |=================================================                                                                                                                                                    |  25%
| As you may have anticipated, you get a negative number. In this case, it's -365, since 1969-01-01 is exactly one calendar year (i.e. 365 days) BEFORE 1970-01-01.

...

  |=======================================================                                                                                                                                              |  28%
| Now, let's take a look at how R stores times. You can access the current date and time using the Sys.time() function with no arguments. Do this and store the result in a variable called t1.

> t1<-Sys.time()

| You are doing so well!

  |============================================================                                                                                                                                         |  31%
| View the contents of t1.

> t1
[1] "2020-11-01 13:17:14 CET"

| Keep working like that and you'll get there!

  |==================================================================                                                                                                                                   |  33%
| And check the class() of t1.

> class(t1)
[1] "POSIXct" "POSIXt" 

| All that hard work is paying off!

  |=======================================================================                                                                                                                              |  36%
| As mentioned earlier, POSIXct is just one of two ways that R represents time information. (You can ignore the second value above, POSIXt, which just functions as a common language between POSIXct and
| POSIXlt.) Use unclass() to see what t1 looks like internally -- the (large) number of seconds since the beginning of 1970.

> unclass(t1)
[1] 1604233035

| That's a job well done!

  |=============================================================================                                                                                                                        |  39%
| By default, Sys.time() returns an object of class POSIXct, but we can coerce the result to POSIXlt with as.POSIXlt(Sys.time()). Give it a try and store the result in t2.

> t2<-as.POSIXlt(Sys.time())

| Keep up the great work!

  |==================================================================================                                                                                                                   |  42%
| Check the class of t2.

> class(t2)
[1] "POSIXlt" "POSIXt" 

| You are amazing!

  |========================================================================================                                                                                                             |  44%
| Now view its contents.

> t2
[1] "2020-11-01 13:18:09 CET"

| Keep working like that and you'll get there!

  |=============================================================================================                                                                                                        |  47%
| The printed format of t2 is identical to that of t1. Now unclass() t2 to see how it is different internally.

> unclass(t2)
$sec
[1] 9.729524

$min
[1] 18

$hour
[1] 13

$mday
[1] 1

$mon
[1] 10

$year
[1] 120

$wday
[1] 0

$yday
[1] 305

$isdst
[1] 0

$zone
[1] "CET"

$gmtoff
[1] 3600

attr(,"tzone")
[1] ""     "CET"  "CEST"

| You are amazing!

  |==================================================================================================                                                                                                   |  50%
| t2, like all POSIXlt objects, is just a list of values that make up the date and time. Use str(unclass(t2)) to have a more compact view.

> str(unclass(t2))
List of 11
 $ sec   : num 9.73
 $ min   : int 18
 $ hour  : int 13
 $ mday  : int 1
 $ mon   : int 10
 $ year  : int 120
 $ wday  : int 0
 $ yday  : int 305
 $ isdst : int 0
 $ zone  : chr "CET"
 $ gmtoff: int 3600
 - attr(*, "tzone")= chr [1:3] "" "CET" "CEST"

| Excellent work!

  |========================================================================================================                                                                                             |  53%
| If, for example, we want just the minutes from the time stored in t2, we can access them with t2$min. Give it a try.

> t2$min
[1] 18

| You are doing so well!

  |=============================================================================================================                                                                                        |  56%
| Now that we have explored all three types of date and time objects, let's look at a few functions that extract useful information from any of these objects -- weekdays(), months(), and quarters().

...

  |===================================================================================================================                                                                                  |  58%
| The weekdays() function will return the day of week from any date or time object. Try it out on d1, which is the Date object that contains today's date.

> weekdays(d1)
[1] "Sunday"

| That's a job well done!

  |========================================================================================================================                                                                             |  61%
| The months() function also works on any date or time object. Try it on t1, which is the POSIXct object that contains the current time (well, it was the current time when you created it).

> months(t1)
[1] "November"

| You nailed it! Good job!

  |==============================================================================================================================                                                                       |  64%
| The quarters() function returns the quarter of the year (Q1-Q4) from any date or time object. Try it on t2, which is the POSIXlt object that contains the time at which you created it.

> quarters(t2)
[1] "Q4"

| That's a job well done!

  |===================================================================================================================================                                                                  |  67%
| Often, the dates and times in a dataset will be in a format that R does not recognize. The strptime() function can be helpful in this situation.

...

  |=========================================================================================================================================                                                            |  69%
| strptime() converts character vectors to POSIXlt. In that sense, it is similar to as.POSIXlt(), except that the input doesn't have to be in a particular format (YYYY-MM-DD).

...

  |==============================================================================================================================================                                                       |  72%
| To see how it works, store the following character string in a variable called t3: "October 17, 1986 08:24" (with the quotes).

> t3<-"October 17, 1986 08:24"

| That's a job well done!

  |====================================================================================================================================================                                                 |  75%
| Now, use strptime(t3, "%B %d, %Y %H:%M") to help R convert our date/time object to a format that it understands. Assign the result to a new variable called t4. (You should pull up the documentation for
| strptime() if you'd like to know more about how it works.)

> t4<-strptime(t3, "%B %d, %Y %H:%M")

| Excellent job!

  |=========================================================================================================================================================                                            |  78%
| Print the contents of t4.

> t4
[1] "1986-10-17 08:24:00 CET"

| Keep up the great work!

  |===============================================================================================================================================================                                      |  81%
| That's the format we've come to expect. Now, let's check its class().

> class(t4)
[1] "POSIXlt" "POSIXt" 

| Nice work!

  |====================================================================================================================================================================                                 |  83%
| Finally, there are a number of operations that you can perform on dates and times, including arithmetic operations (+ and -) and comparisons (<, ==, etc.)

...

  |==========================================================================================================================================================================                           |  86%
| The variable t1 contains the time at which you created it (recall you used Sys.time()). Confirm that some time has passed since you created t1 by using the 'greater than' operator to compare it to the
| current time: Sys.time() > t1

> Sys.time() > t1
[1] TRUE

| Excellent job!

  |===============================================================================================================================================================================                      |  89%
| So we know that some time has passed, but how much? Try subtracting t1 from the current time using Sys.time() - t1. Don't forget the parentheses at the end of Sys.time(), since it is a function.

> Sys.time() - t1
Time difference of 5.034045 mins

| You are quite good my friend!

  |=====================================================================================================================================================================================                |  92%
| The same line of thinking applies to addition and the other comparison operators. If you want more control over the units when finding the above difference in times, you can use difftime(), which allows
| you to specify a 'units' parameter.

...

  |==========================================================================================================================================================================================           |  94%
| Use difftime(Sys.time(), t1, units = 'days') to find the amount of time in DAYS that has passed since you created t1.

> difftime(Sys.time(), t1, units = 'days')
Time difference of 0.003847358 days

| You are really on a roll!

  |================================================================================================================================================================================================     |  97%
| In this lesson, you learned how to work with dates and times in R. While it is important to understand the basics, if you find yourself working with dates and times often, you may want to check out the
| lubridate package by Hadley Wickham.

...

  |=====================================================================================================================================================================================================| 100%
| Would you like to receive credit for completing this course on Coursera.org?

1: No
2: Yes

Selection: 2
What is your email address? rjimenez@comunicaciones.es
What is your assignment token? mGJt0RoNI0EQHAge
Grade submission succeeded!

| You are amazing!

| You've reached the end of this lesson! Returning to the main menu...

| Please choose a course, or type 0 to exit swirl.

1: R Programming
2: Take me to the swirl course repository!

Selection: 2

| OK. I'm opening the swirl courses web page in your browser.

| Leaving swirl now. Type swirl() to resume.

> cube <- function(x, n) {
+     x^3
+ }
> cube(3)
[1] 27
> 
